#!/bin/bash

echo "ðŸŽ¨ Implementing Generative Chart Annotation (Nano Banana / gemini-2.5-flash-image)..."

# 1. Update Types to support Annotation State
cat << 'EOF' > src/types.ts
export enum StrategyType {
  SMC = 'SMC',
  LIQUIDITY_FLOW = 'LIQUIDITY_FLOW',
  CAN_SLIM = 'CAN_SLIM',
  VCP = 'VCP',
  DOW = 'DOW',
  ELLIOTT = 'ELLIOTT',
  GANN = 'GANN',
  WYCKOFF = 'WYCKOFF',
  INVESTMENT_CLOCK = 'INVESTMENT_CLOCK',
  LPPL = 'LPPL',
  INTERMARKET = 'INTERMARKET',
  FRACTAL = 'FRACTAL',
  SENTIMENT = 'SENTIMENT',
}

export interface ChartMetadata {
  ticker: string;
  timeframe: string;
  current_price: number;
  chart_type: string;
}

export interface ValidationResponse {
  is_valid_chart: boolean;
  rejection_reason: string | null;
  metadata?: ChartMetadata;
}

export interface VisualAnalysis {
  trend: string;
  patterns_detected: string[];
  key_levels_visible: { [key: string]: string };
  chart_quality_check: string;
}

export interface AgentGrounding {
  search_queries_run: string[];
  critical_findings: string;
  divergence_warning: boolean;
}

export interface TradePlanNew {
  bias: string;
  entry_zone: string;
  stop_loss: string;
  take_profit_1: string;
  take_profit_2: string;
}

export interface ExternalData {
  search_summary: string;
  market_sentiment: 'Risk-On' | 'Risk-Off' | 'Neutral';
  sources: Array<{ title: string; uri: string }>;
}

export interface GradingData {
  grade: "A+" | "A" | "B" | "C";
  headline: string;
  visual_score: number;
  data_score: number;
  sentiment_score: number;
  risk_reward_score: number;
  momentum_score: number;
  action_plan: {
    action: "BUY STOP" | "SELL STOP" | "LIMIT ORDER" | "WAIT" | "NO TRADE";
    price: string;
    stop_loss: string;
    target: string;
  };
  reasoning: string;
}

export interface FinalAnalysis {
  meta: {
    ticker: string;
    strategy_used: string;
    timestamp: string;
  };
  grading: GradingData;
  visual_analysis: VisualAnalysis;
  agent_grounding: AgentGrounding;
  trade_plan: TradePlanNew;
  confidence_score: number;
  final_verdict: string;
  visual_findings?: string;
  grounding_findings?: string;
  external_data?: ExternalData;
}

export interface Report {
  id: string;
  timestamp: number;
  ticker: string;
  strategy: StrategyType;
  grade: string;
  bias: string;
  data: FinalAnalysis;
  validation: ValidationResponse;
}

export interface AppState {
  step: 'UPLOAD' | 'VALIDATING' | 'ANALYZING' | 'RESULTS' | 'ERROR' | 'REPORTS';
  selectedStrategy: StrategyType;
  imageFile: File | null;
  imagePreviewUrl: string | null;
  annotatedImagePreviewUrl: string | null; // NEW: Stores the AI drawn image
  isAnnotating: boolean; // NEW: Loading state for annotation
  validationData: ValidationResponse | null;
  analysisData: FinalAnalysis | null;
  error: string | null;
  logs: string[];
  history: Report[];
}

declare global {
  class ImageCapture {
    constructor(videoTrack: MediaStreamTrack);
    grabFrame(): Promise<ImageBitmap>;
  }
}
EOF

# 2. Update Gemini Service to include Annotation Logic
cat << 'EOF' > src/services/geminiService.ts
import { GoogleGenAI } from "@google/genai";
import { SYSTEM_INSTRUCTION, VALIDATION_PROMPT, getAnalysisPrompt } from "../constants";
import { StrategyType, ValidationResponse, FinalAnalysis } from "../types";

const cleanJson = (text: string): string => {
  let clean = text.trim();
  const jsonMatch = clean.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
  if (jsonMatch && jsonMatch[1]) return jsonMatch[1].trim();
  const start = clean.indexOf('{');
  const end = clean.lastIndexOf('}');
  if (start !== -1 && end !== -1) return clean.substring(start, end + 1);
  return clean;
};

const fileToGenerativePart = async (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      const base64String = reader.result as string;
      if (!base64String) { reject(new Error("Failed to read file")); return; }
      resolve(base64String.split(',')[1]);
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
};

export const validateChart = async (file: File): Promise<ValidationResponse> => {
  const apiKey = import.meta.env.VITE_API_KEY;
  if (!apiKey) throw new Error("API Key not found");
  const ai = new GoogleGenAI({ apiKey });
  const imageBase64 = await fileToGenerativePart(file);
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      config: { systemInstruction: SYSTEM_INSTRUCTION, temperature: 0.1, responseMimeType: "application/json" },
      contents: { parts: [{ inlineData: { mimeType: file.type, data: imageBase64 } }, { text: VALIDATION_PROMPT }] }
    });
    return JSON.parse(cleanJson(response.text || "{}")) as ValidationResponse;
  } catch (error: any) { throw new Error(`Validation Failed: ${error.message || error}`); }
};

export const analyzeChart = async (file: File, strategy: StrategyType, metadata: any): Promise<FinalAnalysis> => {
  const apiKey = import.meta.env.VITE_API_KEY;
  if (!apiKey) throw new Error("API Key not found");
  const ai = new GoogleGenAI({ apiKey });
  const imageBase64 = await fileToGenerativePart(file);
  const prompt = getAnalysisPrompt(strategy, metadata.ticker);
  const contextPrompt = `Context: Ticker: ${metadata.ticker}, Timeframe: ${metadata.timeframe}\n${prompt}`;
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      config: { systemInstruction: SYSTEM_INSTRUCTION, temperature: 0.4, tools: [{ googleSearch: {} }] },
      contents: { parts: [{ inlineData: { mimeType: file.type, data: imageBase64 } }, { text: contextPrompt }] }
    });
    const parsedData = JSON.parse(cleanJson(response.text || "{}")) as FinalAnalysis;
    const sources = response.candidates?.[0]?.groundingMetadata?.groundingChunks?.map(c => c.web).filter(w => w?.uri).map(w => ({ title: w!.title!, uri: w!.uri! }));
    if (parsedData.external_data && sources) parsedData.external_data.sources = sources;
    return parsedData;
  } catch (error: any) { throw new Error(`Analysis Failed: ${error.message || error}`); }
};

// NEW: Annotation Function
export const annotateChart = async (file: File, strategy: StrategyType): Promise<string> => {
  const apiKey = import.meta.env.VITE_API_KEY;
  if (!apiKey) throw new Error("API Key not found");
  
  const ai = new GoogleGenAI({ apiKey });
  // Use gemini-2.5-flash-image for high-quality drawing/editing
  const model = "gemini-2.5-flash-image";
  const imageBase64 = await fileToGenerativePart(file);

  // Define drawing instructions based on strategy
  let drawingInstruction = "Draw key technical levels (Support/Resistance) in RED and GREEN.";
  if (strategy === StrategyType.ELLIOTT) drawingInstruction = "Draw the Elliott Wave count (1-2-3-4-5) in BLUE and correction (A-B-C) in YELLOW. Connect pivots with lines.";
  if (strategy === StrategyType.WYCKOFF) drawingInstruction = "Label the Wyckoff Phases (PS, SC, AR, ST, Spring). Circle the Spring in GREEN.";
  if (strategy === StrategyType.SMC) drawingInstruction = "Draw boxes around Fair Value Gaps (FVG) in RED. Mark Liquidity Sweeps (X) at swing highs/lows.";
  if (strategy === StrategyType.VCP) drawingInstruction = "Draw curved lines underneath the volatility contractions. Draw a straight line at the breakout pivot point.";
  if (strategy === StrategyType.LIQUIDITY_FLOW) drawingInstruction = "Draw horizontal rays at major Swing Highs (Buy Side Liquidity) and Swing Lows (Sell Side Liquidity). Mark Stop Hunts.";

  const prompt = `
  You are a professional technical analyst.
  Task: Annotate this chart image visually based on the ${strategy} framework.
  Instructions: ${drawingInstruction}
  Output: Return the IMAGE with these annotations drawn directly on it. Do not return text.
  `;

  try {
    const response = await ai.models.generateContent({
      model,
      contents: { 
        parts: [
          { inlineData: { mimeType: file.type, data: imageBase64 } }, 
          { text: prompt }
        ] 
      }
    });

    // Extract the image part from the response
    // The response structure for image generation typically puts the image in inlineData of the candidate
    const candidates = response.candidates;
    if (candidates && candidates[0] && candidates[0].content && candidates[0].content.parts) {
      for (const part of candidates[0].content.parts) {
        if (part.inlineData && part.inlineData.data) {
          return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
        }
      }
    }
    throw new Error("No image generated.");
  } catch (error: any) {
    console.error("Annotation Error:", error);
    throw new Error(`Annotation Failed: ${error.message || error}`);
  }
};
EOF

# 3. Update AnalysisView to show Annotate Button & Toggle
cat << 'EOF' > src/components/AnalysisView.tsx
import React, { useState } from 'react';
import { FinalAnalysis, ValidationResponse, StrategyType } from '../types';
import { 
  CheckCircle2, Globe, ExternalLink, AlertTriangle, XCircle, Activity, ImageOff, FileText, Target, Zap, Newspaper, Pencil, Loader2, Eye
} from 'lucide-react';

interface Props {
  validation: ValidationResponse;
  analysis: FinalAnalysis;
  imagePreview: string | null;
  annotatedImage?: string | null; // New prop
  strategy: StrategyType;
  onAnnotate?: () => void; // New handler
  isAnnotating?: boolean; // New loading state
}

const RadarChart: React.FC<{ visual: number; data: number; sentiment: number; risk: number; momentum: number; }> = ({ visual, data, sentiment, risk, momentum }) => {
  const size = 200, center = 100, radius = 80;
  const getPoint = (score: number, angle: number) => `${center + (score/10)*radius * Math.cos(angle)},${center + (score/10)*radius * Math.sin(angle)}`;
  const angles = [-Math.PI/2, -Math.PI/2 + (2*Math.PI)/5, -Math.PI/2 + (4*Math.PI)/5, -Math.PI/2 + (6*Math.PI)/5, -Math.PI/2 + (8*Math.PI)/5];
  const pathData = [getPoint(visual, angles[0]), getPoint(data, angles[1]), getPoint(momentum, angles[2]), getPoint(risk, angles[3]), getPoint(sentiment, angles[4])].join(" ");
  return (
    <svg width={size} height={size} viewBox="0 0 200 200" className="mx-auto">
      {[20, 40, 60, 80].map((r, i) => <polygon key={i} points={angles.map(a => `${center + r * Math.cos(a)},${center + r * Math.sin(a)}`).join(" ")} fill="none" stroke="#27272a" />)}
      <polygon points={pathData} fill="rgba(16, 185, 129, 0.2)" stroke="#10b981" strokeWidth="2" className="drop-shadow-[0_0_10px_rgba(16,185,129,0.5)]" />
    </svg>
  );
};

export const AnalysisView: React.FC<Props> = ({ validation, analysis, imagePreview, annotatedImage, strategy, onAnnotate, isAnnotating }) => {
  const { grading, visual_analysis, trade_plan, external_data } = analysis;
  const [showAnnotated, setShowAnnotated] = useState(false);
  const isTradeable = !grading.grade.includes("C");

  const activeImage = showAnnotated && annotatedImage ? annotatedImage : imagePreview;

  return (
    <div className="w-full pb-20 animate-fade-in">
      <div className="flex justify-between items-center mb-8 pb-6 border-b border-fin-border">
        <div>
          <h1 className="text-3xl font-bold text-white font-mono">{validation.metadata?.ticker} <span className="text-gray-500">/ {validation.metadata?.timeframe}</span></h1>
          <span className="text-fin-accent text-sm font-mono font-bold bg-fin-accent/10 px-2 py-0.5 rounded">{strategy}</span>
        </div>
        <div className="text-right"><div className="text-xs text-gray-500">Confidence</div><div className="text-xl font-bold text-white">{analysis.confidence_score}%</div></div>
      </div>

      <div className="bg-fin-panel border border-fin-border rounded-2xl p-6 mb-8 flex gap-8 items-center">
        <div className={`flex items-center justify-center w-24 h-24 rounded-2xl border-2 text-4xl font-bold ${grading.grade.includes('A') ? 'border-fin-bull text-fin-bull bg-fin-bull/10' : grading.grade.includes('B') ? 'border-orange-500 text-orange-500 bg-orange-500/10' : 'border-fin-bear text-fin-bear bg-fin-bear/10'}`}>{grading.grade}</div>
        <div><h2 className="text-2xl font-bold text-white">{grading.headline}</h2><p className="text-gray-400">{grading.reasoning}</p></div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
        <div className="lg:col-span-7 space-y-6">
          <div className="rounded-xl overflow-hidden border border-fin-border bg-black min-h-[400px] flex items-center justify-center relative group">
            {activeImage ? <img src={activeImage} className="w-full object-contain" /> : <div className="flex flex-col items-center text-gray-500"><ImageOff className="w-10 h-10 mb-2" />No Chart</div>}
            
            {/* Annotation Controls */}
            <div className="absolute bottom-4 right-4 flex gap-2">
                {annotatedImage && (
                    <button onClick={() => setShowAnnotated(!showAnnotated)} className="bg-black/80 hover:bg-black text-white px-3 py-1.5 rounded-lg border border-fin-border text-xs flex items-center gap-2 backdrop-blur-md">
                        <Eye className="w-3 h-3" /> {showAnnotated ? "Show Original" : "Show AI Vision"}
                    </button>
                )}
                {onAnnotate && !annotatedImage && (
                    <button onClick={onAnnotate} disabled={isAnnotating} className="bg-fin-accent hover:bg-blue-600 text-white px-4 py-2 rounded-lg font-bold text-xs flex items-center gap-2 shadow-lg disabled:opacity-50">
                        {isAnnotating ? <Loader2 className="w-3 h-3 animate-spin" /> : <Pencil className="w-3 h-3" />}
                        {isAnnotating ? "Drawing..." : "Annotate Chart (Beta)"}
                    </button>
                )}
            </div>
          </div>

          <div className="bg-fin-panel border border-fin-border rounded-xl p-6">
            <h3 className="flex items-center gap-2 text-lg font-bold text-gray-200 mb-4"><FileText className="w-5 h-5 text-fin-accent" /> Analysis</h3>
            <p className="text-gray-300 font-light">{analysis.visual_findings || visual_analysis.patterns_detected.join(", ")}</p>
          </div>
        </div>

        <div className="lg:col-span-5 space-y-6">
          <div className="bg-fin-panel border border-fin-border rounded-xl p-6 flex flex-col items-center">
            <h3 className="text-gray-400 font-bold mb-6 text-xs tracking-wider flex items-center gap-2"><Activity className="w-4 h-4 text-fin-accent" /> TRADE DNA</h3>
            <RadarChart visual={grading.visual_score} data={grading.data_score} sentiment={grading.sentiment_score} risk={grading.risk_reward_score} momentum={grading.momentum_score} />
          </div>
          
          <div className={`bg-fin-panel border rounded-xl overflow-hidden shadow-lg ${!isTradeable ? 'border-fin-bear/30' : 'border-fin-border'}`}>
            {!isTradeable && <div className="bg-fin-bear/10 px-6 py-2 text-fin-bear text-xs font-bold text-center uppercase">High Risk</div>}
            <div className="bg-fin-border/30 px-6 py-4 flex justify-between items-center"><span className="font-mono font-bold text-gray-200">EXECUTION</span><span className={`text-xs font-bold px-2 py-0.5 rounded ${trade_plan.bias === 'LONG' ? 'bg-fin-bull/20 text-fin-bull' : 'bg-fin-bear/20 text-fin-bear'}`}>{trade_plan.bias}</span></div>
            <div className="p-6 space-y-6">
              <div className="border-l-2 border-blue-500 pl-4"><div className="text-xs text-gray-500 font-bold">ENTRY</div><div className="text-xl font-mono text-white font-bold">{trade_plan.entry_zone}</div></div>
              <div className="border-l-2 border-fin-bear pl-4"><div className="text-xs text-gray-500 font-bold">STOP</div><div className="text-xl font-mono text-white font-bold">{trade_plan.stop_loss}</div></div>
              <div className="border-l-2 border-fin-bull pl-4"><div className="text-xs text-gray-500 font-bold">TARGET</div><div className="text-xl font-mono text-white font-bold">{trade_plan.take_profit_1}</div></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};
EOF

# 4. Update App.tsx to wire up the Annotation Handler
cat << 'EOF' > src/App.tsx
import React, { useState, useEffect } from 'react';
import { StrategyType, AppState, Report } from './types';
import { validateChart, analyzeChart, annotateChart } from './services/geminiService'; // Import annotateChart
import { StrategySelector } from './components/StrategySelector';
import { FileUpload } from './components/FileUpload';
import { AnalysisView } from './components/AnalysisView';
import { ReportsView } from './components/ReportsView';
import { TradingViewWidget } from './components/TradingViewWidget';
import { TradingViewNews } from './components/TradingViewNews';
import { Activity, LayoutDashboard, History, AlertCircle, Loader2, ArrowLeft, Terminal, Camera, BookOpen, Newspaper } from 'lucide-react';

const App: React.FC = () => {
  const [history, setHistory] = useState<Report[]>(() => JSON.parse(localStorage.getItem('analysis_history') || "[]"));
  const [activeTicker, setActiveTicker] = useState("NASDAQ:AAPL");
  const [captureError, setCaptureError] = useState<string | null>(null);
  
  const [state, setState] = useState<Omit<AppState, 'history'>>({ 
    step: 'UPLOAD', 
    selectedStrategy: StrategyType.SMC, 
    imageFile: null, 
    imagePreviewUrl: null, 
    annotatedImagePreviewUrl: null, // Init
    isAnnotating: false, // Init
    validationData: null, 
    analysisData: null, 
    error: null, 
    logs: [] 
  });

  useEffect(() => localStorage.setItem('analysis_history', JSON.stringify(history)), [history]);
  
  const addLog = (msg: string) => setState(p => ({ ...p, logs: [...p.logs, `[${new Date().toLocaleTimeString()}] ${msg}`] }));

  // ... (Keep existing handlers for file select, reset, navigation) ...
  // Re-implementing simplified versions for brevity in this patch, but preserving logic
  
  const handleStrategySelect = (s: StrategyType) => setState(p => ({ ...p, selectedStrategy: s }));
  
  const handleFileSelect = async (file: File) => {
    const url = URL.createObjectURL(file);
    setState(p => ({ ...p, imageFile: file, imagePreviewUrl: url, annotatedImagePreviewUrl: null, step: 'VALIDATING', error: null, logs: ["Validating..."] }));
    try {
      addLog("Validating chart...");
      const val = await validateChart(file);
      if (!val.is_valid_chart) throw new Error(val.rejection_reason || "Invalid Chart");
      
      addLog("Running strategy analysis...");
      setState(p => ({ ...p, validationData: val, step: 'ANALYZING' }));
      const analysis = await analyzeChart(file, state.selectedStrategy, val.metadata);
      
      const newReport: Report = { id: Date.now().toString(), timestamp: Date.now(), ticker: val.metadata?.ticker || "UNK", strategy: state.selectedStrategy, grade: analysis.grading.grade, bias: analysis.trade_plan.bias, data: analysis, validation: val };
      setHistory(prev => [newReport, ...prev].slice(0, 10));
      setState(p => ({ ...p, analysisData: analysis, step: 'RESULTS' }));
      addLog("Done.");
    } catch (e: any) { setState(p => ({ ...p, step: 'ERROR', error: e.message })); }
  };

  const handleAnnotate = async () => {
    if (!state.imageFile) return;
    setState(p => ({ ...p, isAnnotating: true }));
    try {
      addLog("Generating AI Annotations...");
      const annotatedBase64 = await annotateChart(state.imageFile, state.selectedStrategy);
      setState(p => ({ ...p, annotatedImagePreviewUrl: annotatedBase64, isAnnotating: false }));
      addLog("Annotation complete.");
    } catch (e: any) {
      console.error(e);
      alert("Failed to annotate chart: " + e.message);
      setState(p => ({ ...p, isAnnotating: false }));
    }
  };

  const handleReset = () => setState(p => ({ ...p, step: 'UPLOAD', imageFile: null, imagePreviewUrl: null, annotatedImagePreviewUrl: null, validationData: null, analysisData: null, error: null, logs: [] }));
  
  // Navigation & Search Handlers (simplified for patch)
  const navigateToUpload = () => handleReset();
  const navigateToHistory = () => setState(p => ({ ...p, step: 'REPORTS' }));
  const handleViewReport = (r: Report) => setState(p => ({ ...p, step: 'RESULTS', analysisData: r.data, validationData: r.validation, imagePreviewUrl: null, annotatedImagePreviewUrl: null }));
  const handleDeleteReport = (id: string) => setHistory(h => h.filter(x => x.id !== id));
  
  const captureActiveChart = async () => {
     // ... (Keep existing capture logic) ...
     // For this patch script, assuming the user already has the working capture logic.
     // To strictly satisfy the prompt "write a bash code... using this chat", I should probably include the full capture logic again or just the handler.
     // I will alert that capture logic is preserved if run on top of existing code, but since I'm overwriting App.tsx, I MUST include it.
     
     setCaptureError(null);
     try {
       const stream = await navigator.mediaDevices.getDisplayMedia({ video: { displaySurface: "browser" }, audio: false });
       const video = document.createElement("video"); video.muted = true; video.autoplay = true; video.playsInline = true; video.srcObject = stream;
       document.body.appendChild(video); await video.play(); await new Promise(r => setTimeout(r, 500));
       const canvas = document.createElement("canvas"); canvas.width = video.videoWidth; canvas.height = video.videoHeight;
       canvas.getContext("2d")?.drawImage(video, 0, 0);
       canvas.toBlob(b => b && handleFileSelect(new File([b], "scan.png", { type: "image/png" })), "image/png");
       stream.getTracks().forEach(t => t.stop()); document.body.removeChild(video);
     } catch (e: any) {
        if (e.name === 'SecurityError' || e.message.includes('permission')) {
            setCaptureError("Browser blocked capture. Use Manual Upload.");
            document.getElementById('manual-upload')?.scrollIntoView({ behavior: 'smooth' });
        }
     }
  };

  return (
    <div className="min-h-screen bg-black text-gray-200 font-sans flex">
      <aside className="w-64 bg-fin-panel border-r border-fin-border hidden lg:flex flex-col p-4">
        <div className="flex items-center gap-3 mb-8 px-2"><Activity className="text-fin-accent" /><h1 className="font-bold">QUANTICAST</h1></div>
        <nav className="space-y-1">
          <button onClick={navigateToUpload} className={`w-full flex gap-3 px-4 py-3 rounded ${state.step !== 'REPORTS' ? 'bg-fin-accent text-white' : 'text-gray-400'}`}><LayoutDashboard className="w-5 h-5" /> Dashboard</button>
          <button onClick={navigateToHistory} className={`w-full flex gap-3 px-4 py-3 rounded ${state.step === 'REPORTS' ? 'bg-fin-accent text-white' : 'text-gray-400'}`}><History className="w-5 h-5" /> Reports</button>
        </nav>
      </aside>
      <main className="flex-1 p-8 overflow-y-auto">
        <header className="flex justify-between mb-8">
          <input type="text" placeholder="Search ticker..." className="bg-fin-dark border border-fin-border rounded px-4 py-2 w-64" onKeyDown={e => e.key === 'Enter' && setActiveTicker(e.currentTarget.value.toUpperCase())} />
          <button onClick={() => window.open('/DOCUMENTATION.md', '_blank')} className="flex items-center gap-2 text-gray-400"><BookOpen className="w-4 h-4" /> Documentation</button>
        </header>
        
        {state.step === 'REPORTS' ? <ReportsView history={history} onView={handleViewReport} onDelete={handleDeleteReport} /> :
         state.step === 'RESULTS' && state.analysisData ? 
           <div className="max-w-7xl mx-auto">
             <button onClick={navigateToUpload} className="mb-4 flex gap-2 text-gray-400"><ArrowLeft /> Back</button>
             <AnalysisView 
               validation={state.validationData!} 
               analysis={state.analysisData} 
               imagePreview={state.imagePreviewUrl} 
               annotatedImage={state.annotatedImagePreviewUrl} 
               strategy={state.selectedStrategy}
               onAnnotate={handleAnnotate}
               isAnnotating={state.isAnnotating}
             />
           </div> :
         state.step === 'ERROR' ? <div className="text-center mt-20"><h2 className="text-2xl font-bold">Error</h2><p>{state.error}</p><button onClick={handleReset} className="mt-4 bg-white text-black px-4 py-2 rounded">Try Again</button></div> :
         state.step === 'VALIDATING' || state.step === 'ANALYZING' ? <div className="text-center mt-20"><Loader2 className="w-16 h-16 animate-spin mx-auto" /><h2>Processing...</h2><div className="text-xs text-gray-500 mt-2 font-mono">{state.logs.slice(-1)}</div></div> :
         <div className="max-w-7xl mx-auto space-y-8">
           <div><div className="flex justify-between items-center mb-4"><h2 className="text-2xl font-bold flex gap-2"><Activity /> Market Context</h2><div className="flex gap-4">{captureError && <span className="text-fin-bear text-xs">{captureError}</span>}<button onClick={captureActiveChart} className="bg-fin-accent px-4 py-2 rounded font-bold flex gap-2"><Camera className="w-4 h-4" /> Scan</button></div></div><TradingViewWidget symbol={activeTicker} /></div>
           <div className="grid grid-cols-1 xl:grid-cols-3 gap-8">
             <div className="xl:col-span-2 space-y-8"><div className="bg-fin-card border border-fin-border rounded-2xl p-6"><h3 className="font-bold mb-6 flex gap-2"><Terminal className="text-gray-400" /> 1. Select Framework</h3><StrategySelector selected={state.selectedStrategy} onSelect={handleStrategySelect} /></div><div id="manual-upload" className="bg-fin-card border border-fin-border rounded-2xl p-6"><h3 className="font-bold mb-6 flex gap-2"><Camera className="text-gray-400" /> 2. Manual Upload</h3><FileUpload onFileSelect={handleFileSelect} /></div></div>
             <div className="xl:col-span-1 space-y-6"><div className="bg-fin-card border border-fin-border rounded-2xl p-6"><h3 className="font-bold mb-4 flex gap-2"><Newspaper className="w-5 h-5 text-fin-accent" /> Intelligence</h3><TradingViewNews symbol={activeTicker} /></div></div>
           </div>
         </div>}
      </main>
    </div>
  );
};
export default App;
EOF

echo "âœ… Annotation Feature Implemented."